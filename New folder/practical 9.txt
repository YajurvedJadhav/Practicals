(a) There are flight paths between cities. If there is a flight between city A and city B, then there is an
edge between the cities. The cost of the edge can be the time taken to reach city B from city A or
the amount of fuel used for the journey. Represent this as a graph, where:
i. Nodes represent airports/cities.
ii. Edges represent flight paths.
Use adjacency list representation of the graph or adjacency matrix representation of the
graph.Check whether the graph is connected or not.
ïƒž
#include <iostream>
using namespace std;
#define MAX 10
class Graph {
int adj[MAX][MAX];
int n;
public:
Graph(int size) {
n = size;
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
adj[i][j] = 0;
}
void addEdge(int u, int v, int cost) {
adj[u][v] = cost;
adj[v][u] = cost;
}
void display() {
cout << "Adjacency Matrix:\n";
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++)
cout << adj[i][j] << " ";
cout << endl;
}
}
void DFS(int v, bool visited[]) {
visited[v] = true;
for (int i = 0; i < n; i++) {
if (adj[v][i] != 0 && !visited[i])
DFS(i, visited);
}
}
bool isConnected() {
bool visited[MAX] = {false};
DFS(0, visited);
for (int i = 0; i < n; i++) {
if (!visited[i]) return false;
}
return true;
}
};
int main() {
int n, edges;
cout << "Enter number of cities: ";
cin >> n;
Graph g(n);
cout << "Enter number of flight paths: ";
cin >> edges;
for (int i = 0; i < edges; i++) {
int u, v, cost;
cout << "Enter edge (city1 city2 cost): ";
cin >> u >> v >> cost;
g.addEdge(u, v, cost);
}
g.display();
if (g.isConnected())
cout << "The graph is connected.\n";
else
cout << "The graph is not connected.\n";
return 0;
}